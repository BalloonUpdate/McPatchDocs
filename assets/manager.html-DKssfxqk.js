import{_ as r,r as c,o as s,c as d,a as e,b as o,d as a,w as l,e as t}from"./app-DE99FDxf.js";const p={},u=t('<h1 id="创建更新包" tabindex="-1"><a class="header-anchor" href="#创建更新包" aria-hidden="true">#</a> 创建更新包</h1><h2 id="准备要更新的文件" tabindex="-1"><a class="header-anchor" href="#准备要更新的文件" aria-hidden="true">#</a> 准备要更新的文件</h2><p>第一步，首先需要决定好哪些文件要更新，哪些不需要。然后把需要更新的文件，复制到<code>workspace</code>目录里去，注意复制时需要保持与在客户端相同的文件结构。</p><p>下面一些栗子可以参考：（不存在的文件夹需要手动创建）</p><ul><li><p>要更新所有模组，复制<code>.minecraft/mods</code>目录</p><ul><li>到<code>mp/workspace/.minecraft/mods</code></li></ul></li><li><p>要更新资源包，复制<code>.minecraft/resourcepacks</code>目录</p><ul><li>到<code>mp/workspace/.minecraft/resourcepacks</code></li></ul></li><li><p>要更新.minecraft目录旁边的<code>新玩家进服教程.txt</code>，复制<code>新玩家进服教程.txt</code>文件</p><ul><li>到<code>mp/workspace/新玩家进服教程.txt</code></li></ul></li><li><p>如果你开了版本隔离，就需要复制<code>.minecraft/versions/your-version/mods</code>目录</p><ul><li>到<code>mp/workspace/.minecraft/versions/your-version/mods</code></li><li>其它文件也是同理，需要复制到versions目录下</li></ul></li></ul><p>到这里你可能已经看出规律了：<code>workspace</code>目录相当于本地的<code>.minecraft</code>的父目录。只有<code>workspace</code>目录和客户端保持相同文件结构，文件才能更新到正确的地方</p><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>若开启了版本隔离，那么要更新的实际上是versions目录下的mods文件夹，具体可以看上面的最后一条例子。（客户端程序本身严格按照管理端摆放的文件结构更新，不会读取任何MC或者启动器的配置信息）</p></div><div class="custom-container warning"><p class="custom-container-title">WARNING</p><p>不要一股脑把整个<code>.minecraft</code>目录全部丢进更新，Minecraft的核心文件和Minecraft的资源文件大部分情况下是不能加入更新的，尤其是打算配置一键启动时，会导致更新失败！</p></div><h2 id="创建首个更新包" tabindex="-1"><a class="header-anchor" href="#创建首个更新包" aria-hidden="true">#</a> 创建首个更新包</h2><p>接下来可以开始创建更新包了，首先双击刚创建的<code>manage.bat</code>脚本即可启动管理端。管理端使用交互式命令行来完成各种操作，即使是在黑框命令行下也非常简单易用</p><p>看到主界面以后，我们输入<code>c</code>或<code>1</code>，按下回车键就可以开始创建第一个更新包。第一个版本号通常输入1.0，当然你也可以输入任何你喜欢的版本号风格，好了之后按Enter确定</p><div class="custom-container warning"><p class="custom-container-title">WARNING</p><p>版本号只能包括大小写字母数字，以及<code>!@#$()_+-=;&#39;,.</code>切勿使用中文，空格，或其它字符</p></div><p>输入版本号之后，程序会列出你对文件的所有更改。因为我们是第一次打更新包，文件很多，我们粗略看一下就好，后续打包建议还是稍微看一下这个列表，确保对文件的修改都是没问题的</p><p>如果给这个版本写更新记录，可以在此时打开<code>changelogs.txt</code>文件，把你的更新记录粘贴进去并保存（更新记录只能使用UTF8编码的纯文本，不支持富文本格式）。如果你不想写更新记录，请直接跳过这一步</p><p>接着输入<code>y</code>开始正式打包，首次打包内容一般都较大，可能会花费相当多的时间，请耐心等待</p><p>等到出现<code>创建版本完成</code>的字样后，就说明打包成功了（更新包文件会保存在public目录下）</p><div class="custom-container danger"><p class="custom-container-title">DANGER</p><p>请勿替换更新包中的任何文件，包中存储的是bzip压缩数据，并非原样存储，胡乱修改会导致客户端报错和后续更新全部失败！（如果你一定要修改包中文件，请在修改完后，使用管理端t命令来验证压缩包完整性）</p></div>',17),h={class:"custom-container danger"},m=e("p",{class:"custom-container-title"},"DANGER",-1),_=e("p",null,"已经发布的更新包不支持撤回，更不能手动删除文件，这会导致后面更新的文件数据错乱，且不会触发任何的报错弹框。此时应该再打一个新的版本来修复上个版本里的问题",-1),f=t('<h2 id="后续发布新版" tabindex="-1"><a class="header-anchor" href="#后续发布新版" aria-hidden="true">#</a> 后续发布新版</h2><p>后续发布新版本很简单，只需要对<code>workspace</code>目录下的文件做修改（就像对本地文件一样修改就好），然后打一个更新包就完成了，管理端会自动检测新旧文件差异生成更新包。</p><p>比如我想要删除客户端的一个模组a.jar再添加一个新的模组b.jar，那么只需要在工作空间目录下删掉a.jar然后复制进去b.jar，接着打包新版本就好</p><p>若新旧文件同名，但文件内容被修改了也只一样的做法：直接覆盖旧文件就好，程序也能自动检测到</p><p>对目录的新建和删除也是一样，该怎么新建怎么新建，该什么删除怎么删除，就就像对本地文件一样进行这些操作</p><p>如果你在工作空间目录改了一些文件，但又觉得不妥，想要还原工作空间到没修改之前，可以启动管理端，输入<code>4</code>或<code>restore</code>来还原</p><h2 id="目录用途说明" tabindex="-1"><a class="header-anchor" href="#目录用途说明" aria-hidden="true">#</a> 目录用途说明</h2>',7),E=e("li",null,"worksapce工作空间目录：服主日常维护客户端文件内容的地方",-1),k={href:"/guide/caution#%E4%B8%8D%E5%B0%8F%E5%BF%83%E4%BF%AE%E6%94%B9%E4%BA%86history%E7%9B%AE%E5%BD%95",target:"_blank",rel:"noopener noreferrer"},v=e("li",null,[o("public公共目录：用来存放历史更新包， "),e("ul",null,[e("li",null,"版本列表文件(versions.txt)—— 这个文件仅1.1版本的管理端才有"),e("li",null,"更新包文件(.zip)—— 这个文件仅1.1版本的管理端才有")])],-1);function x(w,b){const i=c("RouterLink"),n=c("ExternalLinkIcon");return s(),d("div",null,[u,e("div",h,[m,_,e("p",null,[o("若实在需要撤回这个版本，请参考"),a(i,{to:"/guide/tutorial-notices.html#%E7%89%88%E6%9C%AC%E5%8F%91%E9%94%99%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E"},{default:l(()=>[o("版本发错了怎么办")]),_:1})])]),f,e("ol",null,[E,e("li",null,[o("history历史目录：用来作为对比，以计算你对workspace目录做了哪些修改的目录 "),e("ul",null,[e("li",null,[o("此目录由程序自动维护，切勿手动修改，会导致数据错乱，若不小心修改了，参考"),e("a",k,[o("注意事项"),a(n)]),o("来还原")])])]),v])])}const g=r(p,[["render",x],["__file","manager.html.vue"]]);export{g as default};
